<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C Code Display</title>
  <style>
    body {
      background-color: #0d1117;
      color: #e6edf3;
      font-family: "Fira Code", monospace;
      padding: 20px;
    }
    pre {
      background-color: #161b22;
      border-radius: 8px;
      padding: 20px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.5;
      overflow-x: auto;
    }
    code {
      color: #79c0ff;
    }
  </style>
</head>
<body>
  <h2>Example of Inter-Process Communication using Shared Memory in C</h2>
  <pre><code>
// Example of Inter-Process Communication using Shared Memory in C
//Part 1 is done and the file is Data.json


//Part 2
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/types.h>
#include <unistd.h>
#include <wait.h>
#include <string.h>

#include <cjson/cJSON.h> 


#define SEM_SEARCH 0
#define SEM_UPDATE 1
#define SEM_DATABASE 2

#define NUM_SEARCH 5

char *shm;
FILE *fp;
long lSize;
char *buffer;
int shmid;
int semid;

key_t shmkey;
key_t semkey;


int create_database(){
    fp = fopen("Data.json", "rb"); 
    if (!fp) {
        perror("Error opening file");
        return 1;
    }

    fseek(fp, 0L, SEEK_END); 
    lSize = ftell(fp);       
    rewind(fp);              

    
    
    buffer = (char*) malloc(lSize + 2);
    if (!buffer) {
        fclose(fp);
        perror("Memory allocation failed");
        return 1;
    }

    // Read the file into the buffer
    if (fread(buffer, lSize, 1, fp) != 1) {
        fclose(fp);
        free(buffer);
        perror("Error reading file");
        return 1;
    }
    buffer[lSize] = '\0'; 

    fclose(fp); 

    shmid = shmget(IPC_PRIVATE, lSize+1, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        free(buffer);
        return 1;
    }
    return 0;
}

int update_ratings(char *shm) {
    cJSON *json = cJSON_Parse(shm);
    if (!cJSON_IsArray(json)) {
        printf("DEBUG: JSON starts with: %.40s\n", shm);
        printf("Error: JSON not an array!\n");
        cJSON_Delete(json);
        return 0;
    }

    int size = cJSON_GetArraySize(json);
    for (int i = 0; i < size; i += 100) {
        cJSON *movie = cJSON_GetArrayItem(json, i);
        if (movie) {
            cJSON *rating = cJSON_GetObjectItemCaseSensitive(movie, "Rating");
            if (cJSON_IsNumber(rating)) {
                rating->valuedouble += 0.3;
            }
        }
    }

    // Convert JSON back to string and overwrite shared memory
    char *updated = cJSON_PrintUnformatted(json);
    strcpy(shm, updated);
    free(updated);

    printf("Update process %d finished updating ratings.\n", getpid());
    cJSON_Delete(json);
    return 0;
}

// comparator for qsort: sort by decreasing Rating
static int cmp_desc_rating(const void *a, const void *b){
    cJSON *const *pa = (cJSON *const *)a;
    cJSON *const *pb = (cJSON *const *)b;
    cJSON *ra = cJSON_GetObjectItemCaseSensitive(*pa, "Rating");
    cJSON *rb = cJSON_GetObjectItemCaseSensitive(*pb, "Rating");
    double va = (cJSON_IsNumber(ra) ? ra->valuedouble : 0.0);
    double vb = (cJSON_IsNumber(rb) ? rb->valuedouble : 0.0);
    if (va < vb) return 1;
    if (va > vb) return -1;
    return 0;
}

int search_movie(char *shm, char *keyword){
    cJSON *json = cJSON_Parse(shm);
    cJSON *ans[1000];
    int idx = 0;

    if (cJSON_IsArray(json)) {
        int size = cJSON_GetArraySize(json);
        
        for (int i = 0; i < size; i++){
            cJSON *first_item = cJSON_GetArrayItem(json, i);
            if (first_item) {
                cJSON *overview = cJSON_GetObjectItemCaseSensitive(first_item, "Overview");
                if (overview && cJSON_IsString(overview) && strstr(overview->valuestring, keyword) != NULL){
                    ans[idx++] = first_item;
                }
            }
        }

        // sort answers by decreasing Rating
        if (idx > 1) {
            qsort(ans, idx, sizeof(cJSON *), cmp_desc_rating);
        }

        for (int i = 0; i < idx; i++){
            cJSON *item = ans[i];
            if (item) {
                cJSON *title = cJSON_GetObjectItemCaseSensitive(item, "Title");
                cJSON *director = cJSON_GetObjectItemCaseSensitive(item, "Director");
                cJSON *year = cJSON_GetObjectItemCaseSensitive(item, "Year");
                cJSON *rating = cJSON_GetObjectItemCaseSensitive(item, "Rating");
                cJSON *overview = cJSON_GetObjectItemCaseSensitive(item, "Overview");

                if (cJSON_IsString(title) && title->valuestring != NULL) {
                    printf("Title: %s\n", title->valuestring);
                    if (cJSON_IsString(director) && director->valuestring) printf("Director: %s\n", director->valuestring);
                    if (cJSON_IsString(year) && year->valuestring) printf("Year: %s\n", year->valuestring);
                    if (cJSON_IsNumber(rating)) printf("Rating: %.2f\n", rating->valuedouble);
                    if (cJSON_IsString(overview) && overview->valuestring) printf("Overview: %s\n", overview->valuestring);
                    printf("\n-------------------------------------------------------\n");
                }
            }
        }

        printf("Process: %d searched %s : %d\n",getpid(), keyword, idx);
    }
    cJSON_Delete(json);
    return 0;
}


void sem_op_wait(int semid, int semnum){
    struct sembuf sb = {semnum, -1, 0};
    semop(semid, &sb, 1);
}

void sem_op_signal(int semid, int semnum){
    struct sembuf sb = {semnum, 1, 0};
    semop(semid, &sb, 1);
}


int main(){
    // use an existing path for ftok to avoid ENOENT
    semkey = ftok("/tmp", 65);
    shmkey = ftok("/tmp", 75);

    semid = semget(semkey, 3, 0666 | IPC_CREAT);


    semctl(semid, SEM_SEARCH, SETVAL, 5);
    semctl(semid, SEM_UPDATE, SETVAL, 1);
    semctl(semid, SEM_DATABASE, SETVAL, 0); //0 for DB not created yet

    pid_t p_search, p_update;

    
    if (create_database() != 0) {
        return 1; // Error occurred in create_database
    }
    shm = shmat(shmid, NULL, 0);
    strcpy(shm, buffer);
    shm[lSize] = '\0';  // Ensure null termination
    
    
    sem_op_signal(semid, SEM_DATABASE); // signal that DB is ready
    


   for (int i = 0; i < NUM_SEARCH; i++){
        p_search = fork();
        if (p_search == 0){
            sem_op_wait(semid, SEM_DATABASE);
            // return SEM_DATABASE value for others
            sem_op_signal(semid, SEM_DATABASE);

            sem_op_wait(semid, SEM_SEARCH);
            
            char *keyword = "";
            if (i % 3 == 0)
                keyword = "love";
            else if (i % 3 == 1)
                keyword = "action";
            else
                keyword = "drama";

            search_movie(shm, keyword);

            sem_op_signal(semid, SEM_SEARCH);
            exit(0);
        }
    }

    p_update = fork();
    if (p_update == 0){

        sem_op_wait(semid, SEM_DATABASE);
        sem_op_signal(semid, SEM_DATABASE);

        sem_op_wait(semid, SEM_UPDATE);

        update_ratings(shm);

        sem_op_signal(semid, SEM_UPDATE);
        exit(0);
    }


    free(buffer);
    shmdt(shm);


    shmctl(shmid, IPC_RMID, NULL);
    semctl(semid, 0, IPC_RMID);
    return 0;
}

//good counter using mutex and semaphore
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>

#define NITER 1000000
pthread_mutex_t mutex;
int cnt = 0;

void * Count(void * a)
{
    int i, tmp;
    pthread_mutex_lock(&mutex);
    for(i = 0; i < NITER; i++)
    {
        tmp = cnt;      /* copy the global cnt locally */
        tmp = tmp+1;    /* increment the local copy */
        cnt = tmp;      /* store the local value into the global cnt */ 
    }
    pthread_mutex_unlock(&mutex);
}

int main(int argc, char * argv[])
{
    pthread_t tid1, tid2;
    pthread_mutex_init(&mutex,NULL);
    if(pthread_create(&tid1, NULL, Count, NULL))
    {
      printf("\n ERROR creating thread 1");
      exit(1);
    }

    if(pthread_create(&tid2, NULL, Count, NULL))
    {
      printf("\n ERROR creating thread 2");
      exit(1);
    }

    if(pthread_join(tid1, NULL))	/* wait for the thread 1 to finish */
    {
      printf("\n ERROR joining thread");
      exit(1);
    }

    if(pthread_join(tid2, NULL))        /* wait for the thread 2 to finish */
    {
      printf("\n ERROR joining thread");
      exit(1);
    }

    if (cnt < 2 * NITER) 
        printf("\n BOOM! cnt is [%d], should be %d\n", cnt, 2*NITER);
    else
        printf("\n OK! cnt is [%d]\n", cnt);
  
    pthread_exit(NULL);
}


//counter with mutex


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_CHILDREN 2

void perror_exit (char *s)
{
  perror (s);  exit (-1);
}

void *check_malloc(int size)
{
  void *p = malloc (size);
  if (p == NULL) perror_exit ("malloc failed");
  return p;
}

typedef sem_t Semaphore;

Semaphore *make_semaphore (int n)
{
  Semaphore *sem = check_malloc (sizeof(Semaphore));
  int ret = sem_init(sem, 0, n);
  if (ret == -1) perror_exit ("sem_init failed");
  return sem;
}

int sem_signal(Semaphore *sem)
{
  return sem_post(sem);
}

typedef struct {
  int counter;
  int end;
  int *array;
  Semaphore *mutex;
} Shared;

Shared *make_shared (int end)
{
  int i;
  Shared *shared = check_malloc (sizeof (Shared));

  shared->counter = 0;
  shared->end = end;

  shared->array = check_malloc (shared->end * sizeof(int));
  for (i=0; i<shared->end; i++) {
    shared->array[i] = 0;
  }
  shared->mutex = make_semaphore(1);
  return shared;
}

pthread_t make_thread(void *(*entry)(void *), Shared *shared)
{
  int ret;
  pthread_t thread;

  ret = pthread_create (&thread, NULL, entry, (void *) shared);
  if (ret != 0) perror_exit ("pthread_create failed");
  return thread;
}

void join_thread (pthread_t thread)
{
  int ret = pthread_join (thread, NULL);
  if (ret == -1) perror_exit ("pthread_join failed");
}

void child_code (Shared *shared)
{
  printf ("Starting child at counter %d\n", shared->counter);

  while (1) {
    sem_wait(shared->mutex);
    if (shared->counter >= shared->end) {
      sem_signal(shared->mutex);
      return;
    }

    shared->array[shared->counter]++;
    shared->counter++;

    if (shared->counter % 10000 == 0) {
      printf ("%d\n", shared->counter);
    }
    sem_signal(shared->mutex);
  }
}

void *entry (void *arg)
{
  Shared *shared = (Shared *) arg;
  child_code (shared);
  printf ("Child done.\n");
  pthread_exit (NULL);
}

void check_array (Shared *shared)
{
  int i, errors=0;

  printf ("Checking...\n");

  for (i=0; i<shared->end; i++) {
    if (shared->array[i] != 1) errors++;
  }
  printf ("%d errors.\n", errors);
}

int main ()
{
  int i;
  pthread_t child[NUM_CHILDREN];

  Shared *shared = make_shared (100000000);

  for (i=0; i NUM_CHILDREN; i++) {
    child[i] = make_thread (entry, shared);
  }

  for (i=0; i NUM_CHILDREN; i++) {
    join_thread (child[i]);
  }

  check_array (shared);
  return 0;
}


//Producer consuemer problem 
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define N 5
#define COUNT 20

int buf[N], in = 0, out = 0;
sem_t empty, full, mutex;

void* producer(void* arg) {
    for (int i = 1; i <= COUNT; i++) {
        sem_wait(&empty);
        sem_wait(&mutex);

        buf[in] = i;
        in = (in + 1) % N;
        printf("Produced %d\n", i);

        sem_post(&mutex);
        sem_post(&full);
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < COUNT; i++) {
        sem_wait(&full);
        sem_wait(&mutex);

        int item = buf[out];
        out = (out + 1) % N;
        printf("  Consumed %d\n", item);

        sem_post(&mutex);
        sem_post(&empty);
    }
    return NULL;
}

int main() {
    pthread_t p, c;
    sem_init(&empty, 0, N);
    sem_init(&full, 0, 0);
    sem_init(&mutex, 0, 1);

    pthread_create(&p, NULL, producer, NULL);
    pthread_create(&c, NULL, consumer, NULL);

    pthread_join(p, NULL);
    pthread_join(c, NULL);

    return 0;
}

//shared memory 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> //toupper()
#include <sys/ipc.h> //IPC key constants
#include <sys/shm.h> //shmget(), shmat(), shmdt()
#include <unistd.h> 
#include <string.h> //strcpy()

#define SHM_SIZE 1024

int main() {
    int shmid = shmget(IPC_PRIVATE, SHM_SIZE, 0666);
    char *shm;

    if (fork() == 0) { 
        shm = shmat(shmid, NULL, 0);

        //busy wait
        while (shm[0] == '\0'); // wait until parent writes

        for (int i = 0; shm[i] != '\0'; i++)
            shm[i] = toupper((unsigned char)shm[i]);

        shmdt(shm);
        exit(0);
    } 
    
    else { // Parent: write & print
        shm = shmat(shmid, NULL, 0);

        strcpy(shm, "Hello, shared memory!");

        sleep(1); // give child time to process

        printf("Uppercased string: %s\n", shm);

        shmdt(shm);
    }

    return 0;
}


//p threadds id self 
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>



void* child_thread(void* arg) {

    printf("%d: hello, my thread id: %d\n", *((int*)arg),  pthread_self());

    return NULL;
}


int main(int argc, char *argv[]) {
    pthread_t thread[5];
    
    for (int i = 0 ; i < 5; i++){
        pthread_create(&thread[i], NULL, child_thread, &i);
        
    }

    for (int i = 0 ; i < 5; i++){
        pthread_join(thread[i], NULL);    
    }
    return 0;
}


//program wait
#include <stdio.h> 
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(){
	
	printf("Task 3\n\n");
	pid_t p = fork();
	
	
	if (p < 0)
		printf("Forking Failed\n");
		
	else if (p == 0){
		printf("Child is running at %d....Gonna Sleep for 2 seconds\n", getpid());
		sleep(2);
		printf("Child is Done\n\n");
	}
	else{
		int state = 0;
		if (waitpid(p, &state, 0) != -1){
			printf("Parent running after child is done\n");
		}
	}
	
	return 0;
	
}

  </code></pre>
</body>
</html>
