<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C Code Display</title>
  <style>
    body {
      background-color: #0d1117;
      color: #e6edf3;
      font-family: "Fira Code", monospace;
      padding: 20px;
    }
    pre {
      background-color: #161b22;
      border-radius: 8px;
      padding: 20px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.5;
      overflow-x: auto;
    }
    code {
      color: #79c0ff;
    }
  </style>
</head>
<body>
  <h2>Example of Inter-Process Communication using Shared Memory in C</h2>
  <pre><code>

/*
==============================================================
 üß† OS LAB ‚Äî Synchronization & IPC Programs in One File
==============================================================

Includes:
  Q1. Dining Philosophers (pthread_mutex)
  Q2. Producer‚ÄìConsumer (unnamed semaphores)
  Q3. Readers‚ÄìWriters (semaphore + mutex)
  Q4. Message Passing (pipes)
  Q5. Shared Memory Communication
  Q6. Race Condition Demo (with & without mutex)
  Q7. Producer‚ÄìConsumer (named semaphores)
==============================================================
*/

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>
#include <ctype.h>
#include <sys/wait.h>

// =====================================================================
// Q1. Dining Philosophers Problem (Deadlock-Free)
// =====================================================================
#define N 5
pthread_mutex_t forks[N];

void* philosopher(void* num) {
    int id = *(int*)num;
    int left = id;
    int right = (id + 1) % N;

    for (int meals = 0; meals < 3; meals++) { // limit for demo
        printf("Philosopher %d is thinking üí≠\n", id);
        sleep(1);

        // Even -> right first, Odd -> left first
        if (id % 2 == 0) {
            pthread_mutex_lock(&forks[right]);
            pthread_mutex_lock(&forks[left]);
        } else {
            pthread_mutex_lock(&forks[left]);
            pthread_mutex_lock(&forks[right]);
        }

        printf("Philosopher %d is eating üçù\n", id);
        sleep(1);

        pthread_mutex_unlock(&forks[left]);
        pthread_mutex_unlock(&forks[right]);
        printf("Philosopher %d finished eating üí§\n", id);
    }
    return NULL;
}

void run_dining_philosophers() {
    pthread_t threads[N];
    int ids[N];
    for (int i = 0; i < N; i++) pthread_mutex_init(&forks[i], NULL);
    for (int i = 0; i < N; i++) {
        ids[i] = i;
        pthread_create(&threads[i], NULL, philosopher, &ids[i]);
    }
    for (int i = 0; i < N; i++) pthread_join(threads[i], NULL);
    for (int i = 0; i < N; i++) pthread_mutex_destroy(&forks[i]);
}

// =====================================================================
// Q2. Producer‚ÄìConsumer Problem (Unnamed Semaphores)
// =====================================================================
#define BUFFER_SIZE 5
#define NUM_ITEMS 10

int buffer[BUFFER_SIZE];
int in = 0, out = 0;
sem_t empty, full;
pthread_mutex_t mutex;

void* producer(void* a) {
    for (int i = 1; i <= NUM_ITEMS; i++) {
        sem_wait(&empty);
        pthread_mutex_lock(&mutex);
        buffer[in] = i;
        printf("Produced: %d\n", i);
        in = (in + 1) % BUFFER_SIZE;
        pthread_mutex_unlock(&mutex);
        sem_post(&full);
        sleep(1);
    }
    return NULL;
}

void* consumer(void* a) {
    for (int i = 1; i <= NUM_ITEMS; i++) {
        sem_wait(&full);
        pthread_mutex_lock(&mutex);
        int item = buffer[out];
        printf("Consumed: %d\n", item);
        out = (out + 1) % BUFFER_SIZE;
        pthread_mutex_unlock(&mutex);
        sem_post(&empty);
        sleep(1);
    }
    return NULL;
}

void run_producer_consumer() {
    pthread_t prod, cons;
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);
    pthread_mutex_init(&mutex, NULL);
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);
}

// =====================================================================
// Q3. Readers‚ÄìWriters Problem
// =====================================================================
sem_t wrt;
pthread_mutex_t rw_mutex;
int readcount = 0;
int data = 0;

void* reader(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < 3; i++) {
        pthread_mutex_lock(&rw_mutex);
        readcount++;
        if (readcount == 1) sem_wait(&wrt);
        pthread_mutex_unlock(&rw_mutex);

        printf("Reader %d reads data = %d üìñ\n", id, data);
        sleep(1);

        pthread_mutex_lock(&rw_mutex);
        readcount--;
        if (readcount == 0) sem_post(&wrt);
        pthread_mutex_unlock(&rw_mutex);
    }
    return NULL;
}

void* writer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < 3; i++) {
        sem_wait(&wrt);
        data++;
        printf("Writer %d modified data to %d ‚úç\n", id, data);
        sleep(1);
        sem_post(&wrt);
    }
    return NULL;
}

void run_readers_writers() {
    pthread_t rtid[3], wtid[2];
    int rid[3], wid[2];
    sem_init(&wrt, 0, 1);
    pthread_mutex_init(&rw_mutex, NULL);

    for (int i = 0; i < 3; i++) {
        rid[i] = i + 1;
        pthread_create(&rtid[i], NULL, reader, &rid[i]);
    }
    for (int i = 0; i < 2; i++) {
        wid[i] = i + 1;
        pthread_create(&wtid[i], NULL, writer, &wid[i]);
    }
    for (int i = 0; i < 3; i++) pthread_join(rtid[i], NULL);
    for (int i = 0; i < 2; i++) pthread_join(wtid[i], NULL);
    sem_destroy(&wrt);
    pthread_mutex_destroy(&rw_mutex);
}

// =====================================================================
// Q4. Message Passing with Pipes
// =====================================================================
void run_pipes() {
    int fd1[2], fd2[2];
    pipe(fd1);
    pipe(fd2);

    if (fork() == 0) {
        close(fd1[1]);
        close(fd2[0]);
        int arr[5];
        read(fd1[0], arr, sizeof(arr));
        int sum = 0;
        for (int i = 0; i < 5; i++) sum += arr[i];
        write(fd2[1], &sum, sizeof(sum));
        exit(0);
    } else {
        close(fd1[0]);
        close(fd2[1]);
        int arr[5] = {1, 2, 3, 4, 5}, sum;
        write(fd1[1], arr, sizeof(arr));
        read(fd2[0], &sum, sizeof(sum));
        printf("Sum received from child: %d\n", sum);
        wait(NULL);
    }
}

// =====================================================================
// Q5. Shared Memory Communication
// =====================================================================
void run_shared_memory() {
    int shmid = shmget(IPC_PRIVATE, 1024, 0666 | IPC_CREAT);
    char* str = (char*)shmat(shmid, NULL, 0);

    if (fork() == 0) {
        sleep(1);
        for (int i = 0; str[i]; i++)
            str[i] = toupper(str[i]);
        printf("Child: Uppercase: %s\n", str);
        shmdt(str);
        exit(0);
    } else {
        strcpy(str, "hello shared memory");
        printf("Parent: Wrote string: %s\n", str);
        wait(NULL);
        shmdt(str);
        shmctl(shmid, IPC_RMID, NULL);
    }
}

// =====================================================================
// Q6. Race Condition Demo
// =====================================================================
int counter = 0;
pthread_mutex_t lock;

void* inc_no_sync(void* arg) {
    for (int i = 0; i < 100000; i++) counter++;
    return NULL;
}

void* inc_with_mutex(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&lock);
        counter++;
        pthread_mutex_unlock(&lock);
    }
    return NULL;
}

void run_race_condition() {
    pthread_t t1, t2;

    // (a) Without Mutex
    counter = 0;
    pthread_create(&t1, NULL, inc_no_sync, NULL);
    pthread_create(&t2, NULL, inc_no_sync, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Counter (no mutex): %d\n", counter);

    // (b) With Mutex
    counter = 0;
    pthread_mutex_init(&lock, NULL);
    pthread_create(&t1, NULL, inc_with_mutex, NULL);
    pthread_create(&t2, NULL, inc_with_mutex, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    printf("Counter (with mutex): %d\n", counter);
    pthread_mutex_destroy(&lock);
}

// =====================================================================
// Q7. Producer‚ÄìConsumer Problem (Named Semaphores)
// =====================================================================
#define ITEMS_PER_PROD 5
sem_t *empty_named, *full_named, *mutex_named;
int buf2[BUFFER_SIZE];
int in2 = 0, out2 = 0, count2 = 0;

void* named_producer(void* arg) {
    int id = *(int*)arg;
    for (int i = 1; i <= ITEMS_PER_PROD; i++) {
        int item = id * 100 + i;
        sem_wait(empty_named);
        sem_wait(mutex_named);
        buf2[in2] = item;
        in2 = (in2 + 1) % BUFFER_SIZE;
        count2++;
        printf("P%d produced %d\n", id, item);
        fflush(stdout);
        sem_post(mutex_named);
        sem_post(full_named);
        usleep(200000);
    }
    return NULL;
}

void* named_consumer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < ITEMS_PER_PROD * 3; i++) {
        sem_wait(full_named);
        sem_wait(mutex_named);
        if (count2 == 0) {
            sem_post(mutex_named);
            sem_post(full_named);
            break;
        }
        int item = buf2[out2];
        out2 = (out2 + 1) % BUFFER_SIZE;
        count2--;
        printf("C%d consumed %d\n", id, item);
        fflush(stdout);
        sem_post(mutex_named);
        sem_post(empty_named);
        usleep(300000);
    }
    return NULL;
}

void run_named_sem() {
    empty_named = sem_open("/empty_sem", O_CREAT, 0644, BUFFER_SIZE);
    full_named  = sem_open("/full_sem",  O_CREAT, 0644, 0);
    mutex_named = sem_open("/mutex_sem", O_CREAT, 0644, 1);

    int np = 3, nc = 2;
    pthread_t prod[np], cons[nc];
    int ids[np + nc];
    for (int i = 0; i < np; i++) ids[i] = i + 1;
    for (int i = 0; i < nc; i++) ids[np + i] = i + 1;

    for (int i = 0; i < np; i++) pthread_create(&prod[i], NULL, named_producer, &ids[i]);
    for (int i = 0; i < nc; i++) pthread_create(&cons[i], NULL, named_consumer, &ids[np + i]);

    for (int i = 0; i < np; i++) pthread_join(prod[i], NULL);
    for (int i = 0; i < nc; i++) pthread_join(cons[i], NULL);

    sem_close(empty_named);
    sem_close(full_named);
    sem_close(mutex_named);
    sem_unlink("/empty_sem");
    sem_unlink("/full_sem");
    sem_unlink("/mutex_sem");

    printf("Named Semaphore Demo Done ‚úÖ\n");
}

// =====================================================================
// MAIN MENU
// =====================================================================
int main() {
    int choice;
    while (1) {
        printf("\n================ OS LAB MENU ================\n");
        printf("1. Dining Philosophers\n");
        printf("2. Producer‚ÄìConsumer (Unnamed Semaphores)\n");
        printf("3. Readers‚ÄìWriters Problem\n");
        printf("4. Message Passing (Pipes)\n");
        printf("5. Shared Memory Communication\n");
        printf("6. Race Condition Demo\n");
        printf("7. Producer‚ÄìConsumer (Named Semaphores)\n");
        printf("0. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);
        printf("============================================\n");

        switch (choice) {
            case 1: run_dining_philosophers(); break;
            case 2: run_producer_consumer(); break;
            case 3: run_readers_writers(); break;
            case 4: run_pipes(); break;
            case 5: run_shared_memory(); break;
            case 6: run_race_condition(); break;
            case 7: run_named_sem(); break;
            case 0: printf("Goodbye üëã\n"); exit(0);
            default: printf("Invalid choice.\n");
        }
    }
    return 0;
}

/* 				SEMAPHORES

Semaphores are system variables used for process synchronization. You may
think of a semaphore, s, as a variable maintained by the system. A semaphore
can be obtained by a semget() system call. Its initial value can be set by
the semctl() system call. There are two common operations that a process
can perform on a semaphore, s, namely:

	P(s) or wait(s)   :  If the value of s is greater than 0, then
			     this operation decrements the value of s and
			     the calling process continues. Otherwise, if
			     s is 0, then the calling process is blocked on s.

	V(s) or signal(s) :  If any process is blocked on s, then this
			     unblocks (wakes up) the earliest among the
			     processes blocked on s. Otherwise, the value
			     of the semaphore is incremented.

In UNIX/Linux, both P(s) and V(s) can be done with the semop() system call
with appropriate parameters.

*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>	/* Include this to use semaphores */

/* We will define the P(s) and V(s) operations in terms of the semop()
   system call. The syntax of semop is as follows:

	int semop ( int semid, struct sembuf *sops, unsigned nsops)

   where semid is the semaphore identifier returned by the semget()
   system call. The second parameter is a pointer to a structure whichs
   we must pass. The fields of this structure indicates whether we wish
   to perform a P(s) operation or a V(s) operation. Refer to the system
   manual for the third parameter -- we will always use 1 for this
   parameter.
*/

#define P(s) semop(s, &pop, 1)  /* pop is the structure we pass for doing
				   the P(s) operation */
#define V(s) semop(s, &vop, 1)  /* vop is the structure we pass for doing
				   the V(s) operation */

main()
{
	int *a, *b;
	int i,j, count = 50, status;

	int semid1, semid2 ;
	struct sembuf pop, vop ;

	/* In the following  system calls, the second parameter indicates the
	   number of semaphores under this semid. Throughout this lab,
	   give this parameter as 1. If we require more semaphores, we
	   will take them under different semids through separate semget()
	   calls.
	*/

	semid1 = semget(IPC_PRIVATE, 1, 0777|IPC_CREAT);
	semid2 = semget(IPC_PRIVATE, 1, 0777|IPC_CREAT);

	/* The following system calls sets the values of the semaphores
	   semid1 and semid2 to 0 and 1 respectively. */

	semctl(semid1, 0, SETVAL, 0);
	semctl(semid2, 0, SETVAL, 1);

	/*  We now initialize the sembufs pop and vop so that pop is used
	    for P(semid) and vop is used for V(semid). For the fields
	    sem_num and sem_flg refer to the system manual. The third
	    field, namely sem_op indicates the value which should be added
	    to the semaphore when the semop() system call is made. Going
	    by the semantics of the P and V operations, we see that
	    pop.sem_op should be -1 and vop.sem_op should be 1.
	*/
	pop.sem_num = vop.sem_num = 0;
	pop.sem_flg = vop.sem_flg = 0;
	pop.sem_op = -1 ; vop.sem_op = 1 ;

	/*  We now illustrate a producer-consumer situation. The parent process
	    acts as the producer and the child process acts as the consumer.
	    Initially semid1 is zero, hence the consumer blocks. Since
	    semid2 is one, the producer produces (in this case writes some
	    values into the file). After this it wakes up the
	    consumer through the V(semid1) call. The consumer reads the
	    value and in turn performs V(semid2) to wake up the producer.
	    Trace through the code and work out the values of the two
	    semaphores and see how they synchronize the producer and the
	    consumer to wait for each other.
	*/
	if (fork() == 0) {

		/* Child Process::  Consumer */
		FILE *fp;
		int data;

		while (count) {

			P(semid1);
			fp = fopen("datafile","r");
			fscanf(fp, "%d", &data);
			printf("\t\t\t\t Consumer reads %d\n",data);
			fclose(fp);
			V(semid2);
			count--;
		}


	}
	else {

		/* Parent Process:: Producer */
		FILE *fp;
		int data = 0;

		while (count) {

			sleep(1);

			P(semid2);
			fp = fopen("datafile","w");
			fprintf(fp, "%d\n", data);
			printf("Producer writes %d\n", data);
			data++;
			fclose(fp);
			V(semid1);
			count--;
		}
		wait(&status);
		

		/* Semaphores need to be
		   deleted after they are used. In this case also,
		   exactly one process should delete it after making
		   sure that noone else is using it.
		 */

		semctl(semid1, 0, IPC_RMID, 0);
		semctl(semid2, 0, IPC_RMID, 0);
	}
}


// Example of Inter-Process Communication using Shared Memory in C
//Part 1 is done and the file is Data.json


//Part 2
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/types.h>
#include <unistd.h>
#include <wait.h>
#include <string.h>

#include <cjson/cJSON.h> 


#define SEM_SEARCH 0
#define SEM_UPDATE 1
#define SEM_DATABASE 2

#define NUM_SEARCH 5

char *shm;
FILE *fp;
long lSize;
char *buffer;
int shmid;
int semid;

key_t shmkey;
key_t semkey;


int create_database(){
    fp = fopen("Data.json", "rb"); 
    if (!fp) {
        perror("Error opening file");
        return 1;
    }

    fseek(fp, 0L, SEEK_END); 
    lSize = ftell(fp);       
    rewind(fp);              

    
    
    buffer = (char*) malloc(lSize + 2);
    if (!buffer) {
        fclose(fp);
        perror("Memory allocation failed");
        return 1;
    }

    // Read the file into the buffer
    if (fread(buffer, lSize, 1, fp) != 1) {
        fclose(fp);
        free(buffer);
        perror("Error reading file");
        return 1;
    }
    buffer[lSize] = '\0'; 

    fclose(fp); 

    shmid = shmget(IPC_PRIVATE, lSize+1, 0666);
    if (shmid == -1) {
        perror("shmget failed");
        free(buffer);
        return 1;
    }
    return 0;
}

int update_ratings(char *shm) {
    cJSON *json = cJSON_Parse(shm);
    if (!cJSON_IsArray(json)) {
        printf("DEBUG: JSON starts with: %.40s\n", shm);
        printf("Error: JSON not an array!\n");
        cJSON_Delete(json);
        return 0;
    }

    int size = cJSON_GetArraySize(json);
    for (int i = 0; i < size; i += 100) {
        cJSON *movie = cJSON_GetArrayItem(json, i);
        if (movie) {
            cJSON *rating = cJSON_GetObjectItemCaseSensitive(movie, "Rating");
            if (cJSON_IsNumber(rating)) {
                rating->valuedouble += 0.3;
            }
        }
    }

    // Convert JSON back to string and overwrite shared memory
    char *updated = cJSON_PrintUnformatted(json);
    strcpy(shm, updated);
    free(updated);

    printf("Update process %d finished updating ratings.\n", getpid());
    cJSON_Delete(json);
    return 0;
}

// comparator for qsort: sort by decreasing Rating
static int cmp_desc_rating(const void *a, const void *b){
    cJSON *const *pa = (cJSON *const *)a;
    cJSON *const *pb = (cJSON *const *)b;
    cJSON *ra = cJSON_GetObjectItemCaseSensitive(*pa, "Rating");
    cJSON *rb = cJSON_GetObjectItemCaseSensitive(*pb, "Rating");
    double va = (cJSON_IsNumber(ra) ? ra->valuedouble : 0.0);
    double vb = (cJSON_IsNumber(rb) ? rb->valuedouble : 0.0);
    if (va < vb) return 1;
    if (va > vb) return -1;
    return 0;
}

int search_movie(char *shm, char *keyword){
    cJSON *json = cJSON_Parse(shm);
    cJSON *ans[1000];
    int idx = 0;

    if (cJSON_IsArray(json)) {
        int size = cJSON_GetArraySize(json);
        
        for (int i = 0; i < size; i++){
            cJSON *first_item = cJSON_GetArrayItem(json, i);
            if (first_item) {
                cJSON *overview = cJSON_GetObjectItemCaseSensitive(first_item, "Overview");
                if (overview && cJSON_IsString(overview) && strstr(overview->valuestring, keyword) != NULL){
                    ans[idx++] = first_item;
                }
            }
        }

        // sort answers by decreasing Rating
        if (idx > 1) {
            qsort(ans, idx, sizeof(cJSON *), cmp_desc_rating);
        }

        for (int i = 0; i < idx; i++){
            cJSON *item = ans[i];
            if (item) {
                cJSON *title = cJSON_GetObjectItemCaseSensitive(item, "Title");
                cJSON *director = cJSON_GetObjectItemCaseSensitive(item, "Director");
                cJSON *year = cJSON_GetObjectItemCaseSensitive(item, "Year");
                cJSON *rating = cJSON_GetObjectItemCaseSensitive(item, "Rating");
                cJSON *overview = cJSON_GetObjectItemCaseSensitive(item, "Overview");

                if (cJSON_IsString(title) && title->valuestring != NULL) {
                    printf("Title: %s\n", title->valuestring);
                    if (cJSON_IsString(director) && director->valuestring) printf("Director: %s\n", director->valuestring);
                    if (cJSON_IsString(year) && year->valuestring) printf("Year: %s\n", year->valuestring);
                    if (cJSON_IsNumber(rating)) printf("Rating: %.2f\n", rating->valuedouble);
                    if (cJSON_IsString(overview) && overview->valuestring) printf("Overview: %s\n", overview->valuestring);
                    printf("\n-------------------------------------------------------\n");
                }
            }
        }

        printf("Process: %d searched %s : %d\n",getpid(), keyword, idx);
    }
    cJSON_Delete(json);
    return 0;
}


void sem_op_wait(int semid, int semnum){
    struct sembuf sb = {semnum, -1, 0};
    semop(semid, &sb, 1);
}

void sem_op_signal(int semid, int semnum){
    struct sembuf sb = {semnum, 1, 0};
    semop(semid, &sb, 1);
}


int main(){
    // use an existing path for ftok to avoid ENOENT
    semkey = ftok("/tmp", 65);
    shmkey = ftok("/tmp", 75);

    semid = semget(semkey, 3, 0666 | IPC_CREAT);


    semctl(semid, SEM_SEARCH, SETVAL, 5);
    semctl(semid, SEM_UPDATE, SETVAL, 1);
    semctl(semid, SEM_DATABASE, SETVAL, 0); //0 for DB not created yet

    pid_t p_search, p_update;

    
    if (create_database() != 0) {
        return 1; // Error occurred in create_database
    }
    shm = shmat(shmid, NULL, 0);
    strcpy(shm, buffer);
    shm[lSize] = '\0';  // Ensure null termination
    
    
    sem_op_signal(semid, SEM_DATABASE); // signal that DB is ready
    


   for (int i = 0; i < NUM_SEARCH; i++){
        p_search = fork();
        if (p_search == 0){
            sem_op_wait(semid, SEM_DATABASE);
            // return SEM_DATABASE value for others
            sem_op_signal(semid, SEM_DATABASE);

            sem_op_wait(semid, SEM_SEARCH);
            
            char *keyword = "";
            if (i % 3 == 0)
                keyword = "love";
            else if (i % 3 == 1)
                keyword = "action";
            else
                keyword = "drama";

            search_movie(shm, keyword);

            sem_op_signal(semid, SEM_SEARCH);
            exit(0);
        }
    }

    p_update = fork();
    if (p_update == 0){

        sem_op_wait(semid, SEM_DATABASE);
        sem_op_signal(semid, SEM_DATABASE);

        sem_op_wait(semid, SEM_UPDATE);

        update_ratings(shm);

        sem_op_signal(semid, SEM_UPDATE);
        exit(0);
    }


    free(buffer);
    shmdt(shm);


    shmctl(shmid, IPC_RMID, NULL);
    semctl(semid, 0, IPC_RMID);
    return 0;
}

//good counter using mutex and semaphore
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>

#define NITER 1000000
pthread_mutex_t mutex;
int cnt = 0;

void * Count(void * a)
{
    int i, tmp;
    pthread_mutex_lock(&mutex);
    for(i = 0; i < NITER; i++)
    {
        tmp = cnt;      /* copy the global cnt locally */
        tmp = tmp+1;    /* increment the local copy */
        cnt = tmp;      /* store the local value into the global cnt */ 
    }
    pthread_mutex_unlock(&mutex);
}

int main(int argc, char * argv[])
{
    pthread_t tid1, tid2;
    pthread_mutex_init(&mutex,NULL);
    if(pthread_create(&tid1, NULL, Count, NULL))
    {
      printf("\n ERROR creating thread 1");
      exit(1);
    }

    if(pthread_create(&tid2, NULL, Count, NULL))
    {
      printf("\n ERROR creating thread 2");
      exit(1);
    }

    if(pthread_join(tid1, NULL))	/* wait for the thread 1 to finish */
    {
      printf("\n ERROR joining thread");
      exit(1);
    }

    if(pthread_join(tid2, NULL))        /* wait for the thread 2 to finish */
    {
      printf("\n ERROR joining thread");
      exit(1);
    }

    if (cnt < 2 * NITER) 
        printf("\n BOOM! cnt is [%d], should be %d\n", cnt, 2*NITER);
    else
        printf("\n OK! cnt is [%d]\n", cnt);
  
    pthread_exit(NULL);
}


//counter with mutex


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM_CHILDREN 2

void perror_exit (char *s)
{
  perror (s);  exit (-1);
}

void *check_malloc(int size)
{
  void *p = malloc (size);
  if (p == NULL) perror_exit ("malloc failed");
  return p;
}

typedef sem_t Semaphore;

Semaphore *make_semaphore (int n)
{
  Semaphore *sem = check_malloc (sizeof(Semaphore));
  int ret = sem_init(sem, 0, n);
  if (ret == -1) perror_exit ("sem_init failed");
  return sem;
}

int sem_signal(Semaphore *sem)
{
  return sem_post(sem);
}

typedef struct {
  int counter;
  int end;
  int *array;
  Semaphore *mutex;
} Shared;

Shared *make_shared (int end)
{
  int i;
  Shared *shared = check_malloc (sizeof (Shared));

  shared->counter = 0;
  shared->end = end;

  shared->array = check_malloc (shared->end * sizeof(int));
  for (i=0; i<shared->end; i++) {
    shared->array[i] = 0;
  }
  shared->mutex = make_semaphore(1);
  return shared;
}

pthread_t make_thread(void *(*entry)(void *), Shared *shared)
{
  int ret;
  pthread_t thread;

  ret = pthread_create (&thread, NULL, entry, (void *) shared);
  if (ret != 0) perror_exit ("pthread_create failed");
  return thread;
}

void join_thread (pthread_t thread)
{
  int ret = pthread_join (thread, NULL);
  if (ret == -1) perror_exit ("pthread_join failed");
}

void child_code (Shared *shared)
{
  printf ("Starting child at counter %d\n", shared->counter);

  while (1) {
    sem_wait(shared->mutex);
    if (shared->counter >= shared->end) {
      sem_signal(shared->mutex);
      return;
    }

    shared->array[shared->counter]++;
    shared->counter++;

    if (shared->counter % 10000 == 0) {
      printf ("%d\n", shared->counter);
    }
    sem_signal(shared->mutex);
  }
}

void *entry (void *arg)
{
  Shared *shared = (Shared *) arg;
  child_code (shared);
  printf ("Child done.\n");
  pthread_exit (NULL);
}

void check_array (Shared *shared)
{
  int i, errors=0;

  printf ("Checking...\n");

  for (i=0; i<shared->end; i++) {
    if (shared->array[i] != 1) errors++;
  }
  printf ("%d errors.\n", errors);
}

int main ()
{
  int i;
  pthread_t child[NUM_CHILDREN];

  Shared *shared = make_shared (100000000);

  for (i=0; i NUM_CHILDREN; i++) {
    child[i] = make_thread (entry, shared);
  }

  for (i=0; i NUM_CHILDREN; i++) {
    join_thread (child[i]);
  }

  check_array (shared);
  return 0;
}


//Producer consuemer problem 
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define N 5
#define COUNT 20

int buf[N], in = 0, out = 0;
sem_t empty, full, mutex;

void* producer(void* arg) {
    for (int i = 1; i <= COUNT; i++) {
        sem_wait(&empty);
        sem_wait(&mutex);

        buf[in] = i;
        in = (in + 1) % N;
        printf("Produced %d\n", i);

        sem_post(&mutex);
        sem_post(&full);
    }
    return NULL;
}

void* consumer(void* arg) {
    for (int i = 0; i < COUNT; i++) {
        sem_wait(&full);
        sem_wait(&mutex);

        int item = buf[out];
        out = (out + 1) % N;
        printf("  Consumed %d\n", item);

        sem_post(&mutex);
        sem_post(&empty);
    }
    return NULL;
}

int main() {
    pthread_t p, c;
    sem_init(&empty, 0, N);
    sem_init(&full, 0, 0);
    sem_init(&mutex, 0, 1);

    pthread_create(&p, NULL, producer, NULL);
    pthread_create(&c, NULL, consumer, NULL);

    pthread_join(p, NULL);
    pthread_join(c, NULL);

    return 0;
}

//shared memory 
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> //toupper()
#include <sys/ipc.h> //IPC key constants
#include <sys/shm.h> //shmget(), shmat(), shmdt()
#include <unistd.h> 
#include <string.h> //strcpy()

#define SHM_SIZE 1024

int main() {
    int shmid = shmget(IPC_PRIVATE, SHM_SIZE, 0666);
    char *shm;

    if (fork() == 0) { 
        shm = shmat(shmid, NULL, 0);

        //busy wait
        while (shm[0] == '\0'); // wait until parent writes

        for (int i = 0; shm[i] != '\0'; i++)
            shm[i] = toupper((unsigned char)shm[i]);

        shmdt(shm);
        exit(0);
    } 
    
    else { // Parent: write & print
        shm = shmat(shmid, NULL, 0);

        strcpy(shm, "Hello, shared memory!");

        sleep(1); // give child time to process

        printf("Uppercased string: %s\n", shm);

        shmdt(shm);
    }

    return 0;
}


//p threadds id self 
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>



void* child_thread(void* arg) {

    printf("%d: hello, my thread id: %d\n", *((int*)arg),  pthread_self());

    return NULL;
}


int main(int argc, char *argv[]) {
    pthread_t thread[5];
    
    for (int i = 0 ; i < 5; i++){
        pthread_create(&thread[i], NULL, child_thread, &i);
        
    }

    for (int i = 0 ; i < 5; i++){
        pthread_join(thread[i], NULL);    
    }
    return 0;
}


//program wait
#include <stdio.h> 
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(){
	
	printf("Task 3\n\n");
	pid_t p = fork();
	
	
	if (p < 0)
		printf("Forking Failed\n");
		
	else if (p == 0){
		printf("Child is running at %d....Gonna Sleep for 2 seconds\n", getpid());
		sleep(2);
		printf("Child is Done\n\n");
	}
	else{
		int state = 0;
		if (waitpid(p, &state, 0) != -1){
			printf("Parent running after child is done\n");
		}
	}
	
	return 0;
	
}

  </code></pre>
</body>
</html>
